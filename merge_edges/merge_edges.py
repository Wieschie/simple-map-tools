"""
Script that merges 'edge' tiles of aerial imagery with base tiles to prevent a half-tile
empty zone in between the two
"""

import itertools
import os
from PIL import Image
from pathlib import Path
from typing import Iterable, List
from concurrent.futures import ProcessPoolExecutor

# This is the layer you're pasting ONTO
BASE_DIR = "./openmaptiles-north-america"
# This is the layer that will be pasted - sits on top of the base layer
IMAGERY_DIR = "./overlay"
ZOOM_LEVELS = range(10, 14)
NUM_PROCS = 8


def GetSortedSubdirectories(p: Path) -> List[Path]:
    return sorted([x for x in p.iterdir() if x.is_dir()], key=lambda dir: dir.name)


def OverwriteIfEmpty(tile: Path) -> bool:
    """ Checks if the tile generated by gdal2tiles is 'empty' (one color) """
    # empty black tile so just overwrite with the base tile
    if os.path.getsize(tile) == 334:
        print("Overwriting empty tile.")
        try:
            GetCorrespondingBaseTile(tile).save(tile)
            return True
        except (IOError, ValueError) as ex:
            print(f"Error on tile {tile}\n{ex}")
    return False


def GetCorrespondingBaseTile(tile: Path) -> Image.Image:
    """ Looks up and opens the base tile at the same geolocation as the input tile """
    try:
        baseFile = Path(BASE_DIR, tile.parents[1].name, tile.parents[0].name, tile.name)
        img = Image.open(baseFile).convert("RGBA")
        return img
    except FileNotFoundError:
        print(f"Could not find base tile {baseFile}")
        raise


def GetEdgeElements(l: List, edge_size: int) -> List:
    """ Returns a list of the first and last n elements of the input list """
    if len(l) <= edge_size * 2:
        return l
    new_list = []
    for i in GetEdgeNumbers(len(l), edge_size):
        new_list.append(l[i])
    return new_list

def GetEdgeNumbers(length: int, edge_size: int) -> Iterable[int]:
    """ Returns the first and last n elements of range(0, length) """
    if (length < edge_size * 2):
        return range(0, length)
    return itertools.chain(range(0, edge_size), range(length - edge_size, length))

def MergeWithBase(tile: Path) -> bool:
    """ Pastes a tile on top of the corresponding base tile to avoid transparent 'gaps' """
    try:
        background = GetCorrespondingBaseTile(tile)
    except FileNotFoundError:
        return False
    try:
        foreground = Image.open(tile).convert("RGBA")
        background.paste(foreground, (0, 0), foreground)
        background.save(tile)
        return True
    except (IOError, ValueError) as ex:
        print(f"Error on tile {tile}\n{ex}")
    return False


def main():
    tiles_to_overwrite = list()
    tiles_to_merge = list()
    for n in ZOOM_LEVELS:
        zoom_dir = Path(IMAGERY_DIR, str(n))
        x_dir = GetSortedSubdirectories(zoom_dir)

        for i, subdir in enumerate(x_dir):
            tiles = list(subdir.glob("*.png"))

            tiles_to_overwrite += tiles

            # # first and last directories are the left and right most columns - every tile is an edge tile
            # # all other directories are center columns so only a few of the first and last images are on an edge
            # does not handle rotated or non-rectangular overlays - increasing the "edge width" will help with slight variances
            edge_width = 3
            if not (i in GetEdgeNumbers(len(x_dir), edge_width)):
                tiles = GetEdgeElements(sorted(tiles, key=lambda file: file.name), edge_width)

            tiles_to_merge += tiles

        print(f'{len(tiles_to_merge)} tiles to merge for zoom {n}')

    with ProcessPoolExecutor(max_workers=NUM_PROCS) as executor:
        executor.map(OverwriteIfEmpty, tiles_to_overwrite)
    
    with ProcessPoolExecutor(max_workers=NUM_PROCS) as executor:
        executor.map(MergeWithBase, tiles_to_merge)


if __name__ == "__main__":
    main()
